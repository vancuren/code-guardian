import * as vscode from 'vscode';
import { Vulnerability } from '../types';

export class VulnerabilityTreeItem extends vscode.TreeItem {
    constructor(
        public readonly vulnerability: Vulnerability,
        public readonly filePath: string,
        public readonly collapsibleState: vscode.TreeItemCollapsibleState
    ) {
        const label = `Line ${vulnerability.line}: ${vulnerability.message}`;
        super(label, collapsibleState);

        this.tooltip = `${vulnerability.message}\n${vulnerability.suggestion || ''}`;
        this.contextValue = 'vulnerability';

        // Set icon based on severity
        switch (vulnerability.severity) {
            case 'critical':
                this.iconPath = new vscode.ThemeIcon('error', new vscode.ThemeColor('errorForeground'));
                break;
            case 'high':
                this.iconPath = new vscode.ThemeIcon('warning', new vscode.ThemeColor('editorWarning.foreground'));
                break;
            case 'medium':
                this.iconPath = new vscode.ThemeIcon('info', new vscode.ThemeColor('editorInfo.foreground'));
                break;
            case 'low':
                this.iconPath = new vscode.ThemeIcon('circle-outline');
                break;
        }

        // Add command to open file at line
        this.command = {
            command: 'codeGuardian.openAtLine',
            title: 'Open',
            arguments: [filePath, vulnerability.line]
        };
    }
}

export class FileTreeItem extends vscode.TreeItem {
    constructor(
        public readonly filePath: string,
        public readonly vulnerabilities: Vulnerability[],
        public readonly collapsibleState: vscode.TreeItemCollapsibleState = vscode.TreeItemCollapsibleState.Expanded
    ) {
        const fileName = filePath.split('/').pop() || filePath;
        const label = `${fileName} (${vulnerabilities.length} issues)`;
        super(label, collapsibleState);

        this.tooltip = filePath;
        this.contextValue = 'file';
        this.iconPath = vscode.ThemeIcon.File;
    }
}

export class VulnerabilityTreeProvider implements vscode.TreeDataProvider<vscode.TreeItem> {
    private _onDidChangeTreeData: vscode.EventEmitter<vscode.TreeItem | undefined | null | void> = new vscode.EventEmitter<vscode.TreeItem | undefined | null | void>();
    readonly onDidChangeTreeData: vscode.Event<vscode.TreeItem | undefined | null | void> = this._onDidChangeTreeData.event;

    private vulnerabilities: Map<string, Vulnerability[]> = new Map();

    constructor() {}

    refresh(): void {
        this._onDidChangeTreeData.fire();
    }

    updateVulnerabilities(file: string, vulnerabilities: Vulnerability[]) {
        if (vulnerabilities.length === 0) {
            this.vulnerabilities.delete(file);
        } else {
            this.vulnerabilities.set(file, vulnerabilities);
        }
        this.refresh();
    }

    clearAll() {
        this.vulnerabilities.clear();
        this.refresh();
    }

    getTreeItem(element: vscode.TreeItem): vscode.TreeItem {
        return element;
    }

    getChildren(element?: vscode.TreeItem): Thenable<vscode.TreeItem[]> {
        if (!element) {
            // Root level - show files
            const items: FileTreeItem[] = [];
            this.vulnerabilities.forEach((vulns, file) => {
                items.push(new FileTreeItem(file, vulns));
            });
            return Promise.resolve(items);
        } else if (element instanceof FileTreeItem) {
            // File level - show vulnerabilities
            const items = element.vulnerabilities.map(vuln =>
                new VulnerabilityTreeItem(vuln, element.filePath, vscode.TreeItemCollapsibleState.None)
            );
            return Promise.resolve(items);
        }
        return Promise.resolve([]);
    }

    getParent(element: vscode.TreeItem): vscode.ProviderResult<vscode.TreeItem> {
        if (element instanceof VulnerabilityTreeItem) {
            // Find the file that contains this vulnerability
            for (const [file, vulns] of this.vulnerabilities) {
                if (vulns.includes(element.vulnerability)) {
                    return new FileTreeItem(file, vulns);
                }
            }
        }
        return null;
    }
}

export class SuggestionsTreeProvider implements vscode.TreeDataProvider<vscode.TreeItem> {
    private _onDidChangeTreeData: vscode.EventEmitter<vscode.TreeItem | undefined | null | void> = new vscode.EventEmitter<vscode.TreeItem | undefined | null | void>();
    readonly onDidChangeTreeData: vscode.Event<vscode.TreeItem | undefined | null | void> = this._onDidChangeTreeData.event;

    private suggestions: string[] = [];

    refresh(): void {
        this._onDidChangeTreeData.fire();
    }

    updateSuggestions(suggestions: string[]) {
        this.suggestions = suggestions;
        this.refresh();
    }

    getTreeItem(element: vscode.TreeItem): vscode.TreeItem {
        return element;
    }

    getChildren(element?: vscode.TreeItem): Thenable<vscode.TreeItem[]> {
        if (!element) {
            return Promise.resolve(this.suggestions.map(suggestion => {
                const item = new vscode.TreeItem(suggestion, vscode.TreeItemCollapsibleState.None);
                item.iconPath = new vscode.ThemeIcon('lightbulb');
                return item;
            }));
        }
        return Promise.resolve([]);
    }
}